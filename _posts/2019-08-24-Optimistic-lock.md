---
layout: post
title: "Optimistic Lock"
description: "Optimistic Lock 과 결점이라고 생각했지만 아니였던 것"
date: 2019-08-24
tags: [database]
comments: true
share: true
---

Optimistic Lock 은 구현이 간단하고 업데이트를 하게 되면 어쩔 수 없이 발생하는 Lock 을 응용한 점이 마음에 들어 종종 사용하고 있습니다.  

## Optimistic Lock 이란

Optimistic Lock 은 읽어온 테이블 행이 업데이트 되는 시점에 본인이 읽어온 상태와 동일한 상태로부터 업데이트되는 것을 보장하는 기법입니다.
대게 Version 필드를 사용해 구현하는데 SQL 로 표현하면 다음과 같습니다.  

```
UPDATE mymodel SET version = version + 1, ... WHERE id = %s AND version = %s
```

업데이트는 순차적으로 실행되기 때문에 버전 1인 상태에서 동시에 두 요청이 들어오면 전자는 버전을 올렸고 후자의 조건문에 대응되는 행은 존재하지 않게 됩니다.  
업데이트 명령은 몇 개의 행이 업데이트됐는지 반환하기 때문에 업데이트 성공 여부 확인이 가능합니다.  
보통은 업데이트가 실패하면 재시도를 하는데 동시 업데이트가 잦은 만큼 재시도가 많아 지기 때문에 그냥 Lock 을 거는 것보다 느릴 수 있습니다.
낙관적인 잠금이라고 불리는 이유도 업데이트가 빈번하지 않을 것이라고 기대하기 때문이라고 합니다.    

PS
> 반드시 Version 필드만 사용해야하는 것은 아닙니다. 업데이트할 때마다 변경되며 행의 상태를 대표할 수 있는 필드가 있으면 됩니다.

## Optimistic Lock 의 결점이라고 생각했지만 아닌 것.

*지금부터 기술하는 내용은 제 추측이며 사실이 아닙니다!*

트랜젝션을 사용하는 경우 업데이트 문의 반환 값으로만 업데이트의 성공 여부를 알 수 있는 점이 결점입니다.  
트렌젝션은 고립성을 가지기 때문에 두 개의 요청이 동시 들어올 경우 업데이트 문의 반환 값이 둘 다 1인 경우가 있을 수 있습니다. 따라서 트렌젝션 내부에선 업데이트가 성공하지만 둘 중 하나는 커밋 단계에선 반영되지 않습니다.
이 경우 커밋 명령은 업데이트된 행의 개수를 반환하지 않기 때문에 애플리케이션에서 정확한 성공 여부를 알 수 없습니다.  

1. A.BEGIN_TRANSACTION, B.BEGIN_TRANSACTION 이 동시에 실행
2. A.READ, B.READ 동시 실행되고 버전 1 인 ROW_1 을 읽는다.
3. A.UPDATE 가 실행돼 ROW_1 의 버전은 2 가 된다.  
4. 트렌젝션은 독립적이기 때문에 B 가 가진 버전은 여전히 1 이다.  
5. 따라서 B.UPDATE 가 실행돼 ROW_1 의 버전은 2 가 된다.  
6. A.COMMIT 으로 실제 ROW_1 버전이 2 가 된다.
7. B.COMMIT 가 실행 되지만 실제 ROW_1 의 버전이 2 가 되었기 때문에 업데이트는 반영되지 않느다.  

어떠신가요 제 말이 그럴듯했나요? 하지만 틀렸습니다.  
업데이트가 순차적으로 실행 된다는 논리를 단지 업데이트 명령에만 해당한다고 생각했기 때문입니다.  
트렌잭션 A, B 가 고립성을 가지는건 맞습니다. 하지만 A, B 가 같은 행을 업데이트 하는 경우 둘 중 하나의 트렌잭션이 
커밋할 때 까지 대기하게 됩니다. 그래서 위에서 설명한 명령 순서는 실현될 수 없습니다.  

비록 가설은 틀렸지만 이것 때문에 제가 짠 서버가 잘 못 실행되고 있을 수 있다는 생각에 많은 걱정을 했는데 적어도 저 부분 때문에 잘 못될 일은 없을 것 같아서 다행입니다.

