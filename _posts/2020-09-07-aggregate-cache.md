---
layout: post
title: "애그리거트 (모델) 기반으로 캐시 관리하기"
description: ""
date: 2020-09-19
tags: [software]
comments: true
share: true
---

## 개요

캐시를 도입하는 것 자체는 어려운 일은 아닙니다.  
다만 좋은 캐시 전력을 세우기가 참 어려운 것 같습니다.  
그러다가 최근에 괜찮은 전략을 알게 되어 글을 써봅니다.  
바로 모델의 PK를 키로, 모델 객체를 값으로 저장하는 모델 기반 캐시 관리 방법입니다.

사실 이 방식은 예시로도 많이 나오고, 생각하기도 쉽기 때습니다.  
재밌는 것은 예전에는 이 방법이 별로라고 생각했기 때문에 거들떠도 보지 않았습니다.  
예전에 떠올린 단점들 조차 점점 장점으로 보이기 시작하면서 생각이 바뀌었습니다.  

### 어떤 모델을 보여줘야 하는가?

List API에서 보여줄 응답할 모델을 알고 싶다면 디비 쿼리가 필요합니다.  
PK 별로 캐시에 모델을 저장하더라도 PK를 알기 위해선 디비 쿼리가 필요하다는 뜻입니다.  
하지만 PK만 쿼리하는 것은 커버링 인덱스를 (or index only scan)하기 쉽습니다.  
당연히 커버링 인덱스되면 그렇지 않은 경우에 비해 훨씬 빠릅니다.  

실험을 많이하는 제품의 경우 필요한 조건문은 빈번히 달라지곤 합니다.  
이 떄마다 매번 인덱스를 변경하는 것은 합리적이지 못합니다.  
조건문이 절대 바뀌지 않는다고 해도 모든 조건문에 대응하는 필드에 복합 인덱스를 거는 것도 합리적이지 못합니다.  
그럼 결국에 커버링 인덱스의 장점은 사라진다고 생각할 수 있습니다.  

저는 [late row lookup](https://explainextended.com/2009/10/23/mysql-order-by-limit-performance-late-row-lookups/) 이라고 불리는 쿼리 방법에서 영감을 얻었습니다.  
late row lookup은 offset, limit 페이지네이션을 최적화하기 위해 소개된 방법입니다. 예를 들어 다음과 같은 쿼리가 될 수 있습니다.  


```sql
select id from (
    select id
    from users
    where index_field1 = 'foo' and index_field2 = "bar"
    order by id
    offset 10000
) o
JOIN o.id = users.id
where users.not_index_field1 is False
limit 500
```

서브쿼리는 커버링 인덱스 되기 때문에 원본 테이블 히트는 최소화 됩니다.  
저는 SQLAlchemy를 사용하는데 [from_self](https://docs.sqlalchemy.org/en/13/orm/query.html#sqlalchemy.orm.query.Query.from_self)라는 기능으로 쉽게 달성할 수 있었습니다.  
late row lookup은 극한의 가정에 대응해본 것이고 제 경험상으론 빈번하지 않았습니다.  
대부분의 경우 PK 필드만 쿼리하는 것은 커링 인덱싱하기 쉬워집니다.  
(그럼에도 디비 부하가 심한 경우엔 해당 쿼리의 결과인 PK 리스트를 캐시하긴 합니다.)
PK 리스트를 가져온 다음엔 벌크로 캐시를 조회하고 다시 벌크로 디비를 조회합니다.  

뷰 응답 캐시 혹은 쿼리 결과를 캐시를 할 때 최악의 경우는 캐시 -> 디비 히트입니다.  
반면 모델 캐시는 최악의 경우 캐시 -> 디비 -> 캐시 -> 디비를 할 수 있습니다.  
그럼에도 불구하고, 모델 캐시는 다른 전략에 비해 압도적인 캐시 공유률을 가집니다.  
모델의 PK가 같으면 같은 캐시를 바라보기 떄문입니다.  
PK를 얻기 위해 쿼리를 했던, 추천 시스템을 호출했던 상관 없습니다.  
그래서 사용자가 많아지고 같은 모델을 공유할 경우 히트율은 매우 높아집니다.  

Ex) 제가 어떤 모델을 봐서 캐시가 된 경우, 다른 사용자는 캐시 히트할 것입니다.  
Ex) 상품 리스트를 봤고, 상품 상세에 들어간다면 이미 해당 상품은 캐시 되어있을 것입니다.  

### 캐시 무효화하기 쉽다.  

보통 모델은 업데이트 되거나 삭제될 수 있습니다. 이 때 캐시를 날려야합니다.  
모델 캐시는 이 때 대응하는 PK의 캐시키를 하나 날리면 됩니다.    
PK 리스트를 가지고 있는 캐시키는 제거할 필요 없습니다.  
업데이트된 경우엔 캐시에서 사라졌기 때문에 디비에서 다시 읽어옵니다.  
삭제된 경우엔 디비에서도 사라졌기 떄문에 쿼리 결과가 null입니다.  

뷰 혹은 쿼리 캐시를 하는 경우엔 캐시 무효화하기 매우 힘들고 부하가 많이 발생할 수 있습니다.  
모델이 여러 키에 산재되어 있기 떄문입니다. 그래서 보통 무효화를 신경쓰는 대신 유효 시간 (expire)를 짧게 줍니다.  
트래픽이 많은 서비스에선 이것도 의미가 있을 것입니다.   
만약 캐시가 없을 때, 동시에 많은 요청이 온다면 디비 부하가 커질 수 있습니다.  
유효 시간이 짧다면 이런 경우는 매우 빈번할 것입니다.  
이것에 대한 해결 방법도 존재합니다. [인스타 기술 블로그](https://instagram-engineering.com/thundering-herds-promises-82191c8af57d)에서 인사이트를 얻을 수 있습니다.  

### 조인을 자제하게 만든다.

다른 애그리거트 (루트 엔티티)끼리는 조인하면 안된다고 생각합니다.  
그렇게하면 나중에라도 도메인별로 서버를 분리하기 쉽습니다.  
객체 인터페이스도 간단해지고 자연스럽게 테스트도 쉬워집니다.  

예를 들어 `블로그 포스터를 가져올 때 작성자`를 조인으로 가져오지 않습니다.
대신 Blog 리스트로 author_ids 를 만들어서 AuthorRepo.gets 같은 인터페이스에 인자로 넘겨서 authors 리스트를 가져옵니다.   
모델 캐시는 값을 저장할 때 다른 모델을 저장하지 않기 때문에 자연스럽게 조인을 하지 않게 됩니다.  

주의할 점은 조인 자체를 하지 말자는 것은 아닙니다.  
예를 들어 UserPhone 이라는 모델이 디비 사정상 User 모델에 관계로 저장되어 있다면 이 때는 저는 조인하고 캐시에 함께 저장합니다.  
애그리거트가 불완전하지 않길 원하기 때문입니다.
해당 내용에 대해 더 깊게 알고 싶다면, DDD (도매인 주도 설계)를 알아보는 것을 추천드립니다.

### 마무리

모델 캐시를 칭찬하는 글을 썼지만 뷰나 쿼리를 캐시하는 것에 비해서 훨씬 어렵다고 생각합니다.  
모든 것엔 적절한 코드가 있다고 생각합니다.  
상황을 잘 고려해서 좋은 전략을 취할 수 있으면 좋겠습니다!
